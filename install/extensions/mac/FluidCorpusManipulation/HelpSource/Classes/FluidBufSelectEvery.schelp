TITLE:: FluidBufSelectEvery
SUMMARY:: Extract every N samples / channels from a buffer
CATEGORIES:: Libraries>FluidCorpusManipulation
RELATED:: Classes/FluidBufSelect,Classes/Buffer,Classes/Index,Classes/IndexL,Classes/BufRd
DESCRIPTION::

    
    Pick every N frames and / or channels from a buffer, described in terms of independent hop sizes for frames and channels


    

Read more about FluidBufSelectEvery on the link::https://learn.flucoma.org/reference/selectevery##learn platform::.

CLASSMETHODS::

METHOD:: process, processBlocking
  Processs the source LINK::Classes/Buffer:: on the LINK::Classes/Server::. CODE::processBlocking:: will execute directly in the server command FIFO, whereas CODE::process:: will delegate to a separate worker thread. The latter is generally only worthwhile for longer-running jobs where you don't wish to tie up the server.

ARGUMENT:: server
	The LINK::Classes/Server:: on which the buffers to be processed are allocated.








ARGUMENT:: source

    
    The LINK::Classes/Buffer:: to pick values from



ARGUMENT:: startFrame

    
    The starting point (in samples) from which to copy in the source buffer.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numFrames

    
    The duration (in samples) to copy from the source buffer. The default (-1) copies the full length of the buffer.



ARGUMENT:: startChan

    
    The first channel from which to copy in the source buffer.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numChans

    
    The number of channels from which to copy in the source buffer.



ARGUMENT:: destination

    
    The LINK::Classes/Buffer:: to write the selected data to



ARGUMENT:: frameHop

    
    Take every CODE::frameHop:: frames. Default = 1 = all frames (where 2 would be every other frame, etc.)



ARGUMENT:: chanHop

    
    Take every CODE::chanHop:: channels. Default = 1 = all channels (where 2 would be every other channel, etc.)



 
ARGUMENT:: freeWhenDone
  Free the server instance when processing complete. Default CODE::true::

ARGUMENT:: action
	A function to be evaluated once the offline process has finished and all Buffer's instance variables have been updated on the client side. The function will be passed CODE::[features]:: as an argument.

RETURNS:: An instance of the processor

METHOD:: kr
  Trigger the equivalent behaviour to CODE::processBlocking / process:: from a LINK::Classes/Synth::. Can be useful for expressing a sequence of buffer and data processing jobs to execute. Note that the work still executes on the server command FIFO (not the audio thread), and it is the caller's responsibility to manage the sequencing, using the CODE::done:: status of the various UGens.







ARGUMENT:: source

    
    The LINK::Classes/Buffer:: to pick values from



ARGUMENT:: startFrame

    
    The starting point (in samples) from which to copy in the source buffer.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numFrames

    
    The duration (in samples) to copy from the source buffer. The default (-1) copies the full length of the buffer.



ARGUMENT:: startChan

    
    The first channel from which to copy in the source buffer.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numChans

    
    The number of channels from which to copy in the source buffer.



ARGUMENT:: destination

    
    The LINK::Classes/Buffer:: to write the selected data to



ARGUMENT:: frameHop

    
    Take every CODE::frameHop:: frames. Default = 1 = all frames (where 2 would be every other frame, etc.)



ARGUMENT:: chanHop

    
    Take every CODE::chanHop:: channels. Default = 1 = all channels (where 2 would be every other channel, etc.)



 
ARGUMENT:: trig
  A CODE::kr:: signal that will trigger execution

ARGUMENT:: blocking
  Whether to execute this process directly on the server command FIFO or delegate to a worker thread. See CODE::processBlocking/process:: for caveats.


INSTANCEMETHODS::

METHOD:: cancel
  Cancels non-blocking processing

METHOD:: wait
  When called in the context of a LINK::Classes/Routine:: (it won't work otherwise), will block execution until the processor has finished. This can be convinient for writing sequences of processes more linearly than using lots of nested actions.
  
EXAMPLES::
code::
// a buffer with 5 frames and 3 channels,
// where, for the values in the buffer, the tens column
// is the channel, and the ones column is the frame
(
~src = Buffer.loadCollection(s,Array.fill(5,{
	arg frame;
	Array.fill(3,{
		arg chan;
		(chan * 10 ) + frame;
	});
}).flat,3);
)

// print it out and look to check:
(
~src.loadToFloatArray(action:{
	arg fa;
	fa = fa.clump(~src.numChannels).flop;
	fa.do{
		arg chan;
		chan.postln;
	};
});
)

// copy out the odd frames and the even channels
(
~destination = Buffer(s);
FluidBufSelectEvery.processBlocking(s,~src,1,frameHop:2,chanHop:2,destination:~destination,action:{
	~destination.loadToFloatArray(action:{
		arg fa;
		fa = fa.clump(~destination.numChannels).flop;
		fa.do{
			arg chan;
			chan.postln;
		};
	});
});
)
::
strong::Curating Descriptors::
code::

~src = Buffer.read(s,FluidFilesPath("Tremblay-Iterative-M.wav"));

(
~loudnessbuf = Buffer(s);
~statsbuf = Buffer(s);
~selected = Buffer(s);
FluidBufLoudness.processBlocking(s,~src,features:~loudnessbuf);
FluidBufStats.processBlocking(s,~loudnessbuf,stats:~statsbuf,numChans:1,numDerivs:2);
FluidBufSelectEvery.processBlocking(s,~statsbuf,frameHop:7,destination:~selected);
~selected.loadToFloatArray(action:{
	arg fa;
	["mean loudness", "mean of the 1st derivative of loudness","mean of the 2nd derivative of loudness"].do{
		arg name, i;
		"%\t<-- %".format(fa[i],name).postln;
	};
});
)
::