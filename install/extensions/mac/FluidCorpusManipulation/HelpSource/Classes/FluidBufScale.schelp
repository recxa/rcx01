TITLE:: FluidBufScale
SUMMARY:: A Scaling Processor for Buffers
CATEGORIES:: Libraries>FluidCorpusManipulation
RELATED:: Classes/FluidBufThresh,Classes/FluidBufCompose,Classes/FluidBufFlatten,Guides/FluidCorpusManipulation,Guides/FluidBufMultiThreading
DESCRIPTION::

    
    Scale LINK::Classes/Buffer:: values from an input range to an output range.


    
    This object is for scaling LINK::Classes/Buffer:: values. It copies data from a source LINK::Classes/Buffer:: to a destination LINK::Classes/Buffer::, scaling the source from an input range to an output range.


Read more about FluidBufScale on the link::https://learn.flucoma.org/reference/bufscale##learn platform::.

CLASSMETHODS::

METHOD:: process, processBlocking
  Processs the source LINK::Classes/Buffer:: on the LINK::Classes/Server::. CODE::processBlocking:: will execute directly in the server command FIFO, whereas CODE::process:: will delegate to a separate worker thread. The latter is generally only worthwhile for longer-running jobs where you don't wish to tie up the server.

ARGUMENT:: server
	The LINK::Classes/Server:: on which the buffers to be processed are allocated.








ARGUMENT:: source

    
    This is the method that calls for the scaling to be calculated on a given source buffer.



ARGUMENT:: startFrame

    
    The starting point (in samples) from which to copy in the source LINK::Classes/Buffer::.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numFrames

    
    The duration (in samples) to copy from the source LINK::Classes/Buffer::. The default (-1) copies the full length of the LINK::Classes/Buffer::.



ARGUMENT:: startChan

    
    The first channel from which to copy in the source LINK::Classes/Buffer::.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numChans

    
    The number of channels from which to copy in the source LINK::Classes/Buffer::. This parameter will wrap around the number of channels in the source LINK::Classes/Buffer::. The default (-1) copies all LINK::Classes/Buffer:: channels.



ARGUMENT:: destination

    
    The destination LINK::Classes/Buffer::.



ARGUMENT:: inputLow

    
    The low reference value of the input scaling range.



ARGUMENT:: inputHigh

    
    The high reference value of the input scaling range.



ARGUMENT:: outputLow

    
    The low reference value of the output scaling range.



ARGUMENT:: outputHigh

    
    The high reference value of the output scaling range.



ARGUMENT:: clipping

    
    Optional clipping of the input (and therefore of the output). 0 is none. 1 clips the lowest input at inputLow. 2 caps the highest input at inputHigh, 3 caps both input low and high value within the described range.



 
ARGUMENT:: freeWhenDone
  Free the server instance when processing complete. Default CODE::true::

ARGUMENT:: action
	A function to be evaluated once the offline process has finished and all Buffer's instance variables have been updated on the client side. The function will be passed CODE::[features]:: as an argument.

RETURNS:: An instance of the processor

METHOD:: kr
  Trigger the equivalent behaviour to CODE::processBlocking / process:: from a LINK::Classes/Synth::. Can be useful for expressing a sequence of buffer and data processing jobs to execute. Note that the work still executes on the server command FIFO (not the audio thread), and it is the caller's responsibility to manage the sequencing, using the CODE::done:: status of the various UGens.







ARGUMENT:: source

    
    This is the method that calls for the scaling to be calculated on a given source buffer.



ARGUMENT:: startFrame

    
    The starting point (in samples) from which to copy in the source LINK::Classes/Buffer::.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numFrames

    
    The duration (in samples) to copy from the source LINK::Classes/Buffer::. The default (-1) copies the full length of the LINK::Classes/Buffer::.



ARGUMENT:: startChan

    
    The first channel from which to copy in the source LINK::Classes/Buffer::.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numChans

    
    The number of channels from which to copy in the source LINK::Classes/Buffer::. This parameter will wrap around the number of channels in the source LINK::Classes/Buffer::. The default (-1) copies all LINK::Classes/Buffer:: channels.



ARGUMENT:: destination

    
    The destination LINK::Classes/Buffer::.



ARGUMENT:: inputLow

    
    The low reference value of the input scaling range.



ARGUMENT:: inputHigh

    
    The high reference value of the input scaling range.



ARGUMENT:: outputLow

    
    The low reference value of the output scaling range.



ARGUMENT:: outputHigh

    
    The high reference value of the output scaling range.



ARGUMENT:: clipping

    
    Optional clipping of the input (and therefore of the output). 0 is none. 1 clips the lowest input at inputLow. 2 caps the highest input at inputHigh, 3 caps both input low and high value within the described range.



 
ARGUMENT:: trig
  A CODE::kr:: signal that will trigger execution

ARGUMENT:: blocking
  Whether to execute this process directly on the server command FIFO or delegate to a worker thread. See CODE::processBlocking/process:: for caveats.


INSTANCEMETHODS::

METHOD:: cancel
  Cancels non-blocking processing

METHOD:: wait
  When called in the context of a LINK::Classes/Routine:: (it won't work otherwise), will block execution until the processor has finished. This can be convinient for writing sequences of processes more linearly than using lots of nested actions.
  
EXAMPLES::
code::

~raw = Buffer.loadCollection(s,(1..5));

(
~scaled = Buffer(s);
FluidBufScale.processBlocking(s,~raw,destination:~scaled,inputLow:1,inputHigh:5,outputLow:0,outputHigh:1,action:{
	~raw.getn(0,5,{
		arg vals;
		"raw:    %".format(vals).postln;
	});

	~scaled.getn(0,5,{
		arg vals;
		"scaled: %".format(vals).postln;
	});
});
)
::
strong::With Clipping::
code::

~raw = Buffer.loadCollection(s,(1..5));

(
~scaled = Buffer(s);
FluidBufScale.processBlocking(s,~raw,destination:~scaled,inputLow:1,inputHigh:4,outputLow:0,outputHigh:1,clipping:3,action:{
	~raw.getn(0,5,{
		arg vals;
		"raw:    %".format(vals).postln;
	});

	~scaled.getn(0,5,{
		arg vals;
		"scaled: %".format(vals).postln;
	});
});
)
::