TITLE:: FluidMelBands
SUMMARY:: A Perceptually Spread Spectral Contour Descriptor
CATEGORIES:: Libraries>FluidCorpusManipulation
RELATED:: Classes/FluidBufMelBands,Classes/FluidPitch,Classes/FluidLoudness,Classes/FluidMFCC,Classes/FluidSpectralShape,Guides/FluidCorpusManipulation
DESCRIPTION::

    
    Magnitudes for a number of perceptually-evenly spaced bands.


    
    LINK::Classes/FluidMelBands:: returns a Mel-Frequency Spectrum comprised of the user-defined CODE::numBands::. The Mel-Frequency Spectrum is a histogram of FFT bins bundled according their relationship to the Mel scale ( LINK::https://en.wikipedia.org/wiki/Mel_scale:: ) which represents frequency space logarithmically, mimicking how humans perceive pitch distance. The name "Mel" derives from the word "melody". The Hz-to-Mel conversion used by LINK::Classes/FluidMelBands:: is CODE::mel = 1127.01048 * log(hz / 700.0 + 1.0)::. This implementation allows the selection of the range and number of bands dynamically.

    When using a high value for CODE::numBands::, you may end up with empty channels (filled with zeros) in the MelBands output. This is because there is not enough information in the FFT analysis to properly calculate values for every MelBand. Increasing the CODE::fftSize:: will ensure you have values for all the MelBands.

    Visit LINK::https://learn.flucoma.org/reference/melbands:: to learn more.


Read more about FluidMelBands on the link::https://learn.flucoma.org/reference/melbands##learn platform::.

CLASSMETHODS::

METHOD:: kr

ARGUMENT:: in

  Audio-rate signal to analyze








ARGUMENT:: numBands

    
    The number of bands that will be perceptually equally distributed between CODE::minFreq:: and CODE::maxFreq::. It is limited by the maxNumBands parameter. When the number is smaller than the maximum, the output is zero-padded.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::2::

    ## 
    Maximum: CODE::maxnumBands::

    ::


ARGUMENT:: minFreq

    
    The lower bound of the frequency band to use in analysis, in Hz. The default is 20.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: maxFreq

    
    The upper bound of the frequency band to use in analysis, in Hz. The default is 20000.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: normalize

    
    This flag indicates whether to use normalized triangle filters, which account for the number of FFT magnitudes used to calculate the MelBands. When normalization is off ( = 0) the higher MelBands tend to be disproportionately large because they are summing more FFT magnitudes. The default is to have normalization on ( = 1).



ARGUMENT:: scale

    
    This flag sets the scaling of the output value. It is either linear (0, by default) or in dB (1).



ARGUMENT:: windowSize

    
    The window size. As spectral description relies on spectral frames, we need to decide what precision we give it spectrally and temporally. For more information visit LINK::https://learn.flucoma.org/learn/fourier-transform/::



ARGUMENT:: hopSize

    
    The window hop size. As spectral description relies on spectral frames, we need to move the window forward. It can be any size, but low overlap will create audible artefacts. The -1 default value will default to half of windowSize (overlap of 2).



ARGUMENT:: fftSize

    
    The inner FFT/IFFT size. It should be at least 4 samples long, at least the size of the window, and a power of 2. Making it larger allows an oversampling of the spectral precision. The -1 default value will default to windowSize.



ARGUMENT:: maxFFTSize

    
    Set an explicit upper bound on the FFT size at object instantiation. The default of CODE::nil:: or -1 sets this to whatever the initial FFT size is



ARGUMENT:: maxNumBands

    
    Manually sets a maximum value for CODE::numBands::. Can only be set at object instantiation. Default value of -1 sets this to the initial value of CODE::numBands::



 
 

RETURNS::     
    A KR signal of CODE::maxNumBands channels::, giving the measured magnitudes for each band. The latency is windowSize.



INSTANCEMETHODS::
  
EXAMPLES::
STRONG::Use the magnitudes of the melbands analysis to drive a bank of sine oscillators to "resynthesize" the drum loop::
code::
//load a source
~drums = Buffer.read(s,FluidFilesPath("Nicol-LoopE-M.wav"));

(
x = {
	arg mix = 0.5;
	var source = PlayBuf.ar(1,~drums,BufRateScale.ir(~drums),loop:1);
	var numBands = 40;
	var windowSize = 1024;
	var hopSize = windowSize / 2;
	var melBands = FluidMelBands.kr(
		source,
		numBands,
		maxNumBands:numBands,
		windowSize:windowSize,
		hopSize:hopSize
	);
	var lowMel =  1127.010498 * ((20/700) + 1).log; // convert from hz to mels
	var highMel = 1127.010498 * ((20000/700) + 1).log; // convert from hz to mels
	var rangeMel = highMel - lowMel;
	var stepMel = rangeMel / (numBands+1);
	var freqMel = Array.fill(numBands,{arg i; (stepMel * (i+1)) + lowMel});
	var freqHz = ((freqMel/ 1127.01048).exp - 1) * 700; // convert from mel to hz
	var sines = SinOsc.ar(freqHz,0,melBands.lag(hopSize*SampleDur.ir)).sum;
	var sig = [
		DelayN.ar(source,delaytime:windowSize*SampleDur.ir), // compensate for latency
		sines
	];
	sig = sig * [1-mix,mix];
	sig;
}.play;
)

x.set(\mix,1);

::
STRONG::Use the mouse to select a different band of analysis::
code::
~drums = Buffer.read(s,FluidFilesPath("Nicol-LoopE-M.wav"));

(
x = {
	arg mix = 0.5;
	var source = PlayBuf.ar(1,~drums,BufRateScale.ir(~drums),loop:1);
	var numBands = 40;
	var windowSize = 1024;
	var hopSize = windowSize / 2;
	var melBands = FluidMelBands.kr(
		source,
		numBands,
		minFreq:MouseX.kr.exprange(20,600),
		maxFreq:MouseY.kr.exprange(650,20000),
		maxNumBands:numBands,
		windowSize:windowSize,
		hopSize:hopSize
	);
	var lowMel =  1127.010498 * ((20/700) + 1).log; // convert from hz to mels
	var highMel = 1127.010498 * ((20000/700) + 1).log; // convert from hz to mels
	var rangeMel = highMel - lowMel;
	var stepMel = rangeMel / (numBands+1);
	var freqMel = Array.fill(numBands,{arg i; (stepMel * (i+1)) + lowMel});
	var freqHz = ((freqMel/ 1127.01048).exp - 1) * 700; // convert from mel to hz
	var sines = SinOsc.ar(freqHz,0,melBands.lag(hopSize*SampleDur.ir)).sum;
	var sig = [
		DelayN.ar(source,delaytime:windowSize*SampleDur.ir), // compensate for latency
		sines
	];
	sig = sig * [1-mix,mix];
	sig;
}.play;
)

x.set(\mix,1);
::
STRONG::Display a chart to see the MelBands::
code::

//create a monitoring window for the values
(
~win = Window("Mel Bands Monitor", Rect(10, 10, 620, 320)).front;
~ms = MultiSliderView(~win,
	Rect(0,0,~win.bounds.width,~win.bounds.height)
).elasticMode_(1).isFilled_(1);
)

//play a simple sound to observe the values
(
OSCdef(\melBands,{
	arg msg;
	var melBands, numBands = msg[3];
	melBands = msg[4..(4+(numBands-1)).asInteger];
	defer{~ms.value_(melBands)};
},"/melBands");

x = {
	arg numBands = 40;
	var source = SinOsc.ar(LFTri.kr(0.1).exprange(80,800),0,0.1);
	var melBands = FluidMelBands.kr(source,numBands:numBands,maxNumBands:40);
	SendReply.kr(Impulse.kr(30),"/melBands",[numBands] ++ melBands);
	source.dup;
}.play;
)

// free this source
x.free

// load a more exciting one
c = Buffer.read(s,FluidFilesPath("Tremblay-AaS-SynthTwoVoices-M.wav"));

// analyse with parameters to be changed
(
OSCdef(\melBands,{
	arg msg;
	var melBands, numBands = msg[3];
	melBands = msg[4..(4+(numBands-1)).asInteger];
	defer{~ms.value_(melBands)};
},"/melBands");

x = {
	arg numBands = 40, minFreq = 20, maxFreq = 20000;
	var source = PlayBuf.ar(1,c,loop:1);
	var melBands = FluidMelBands.kr(source,numBands,minFreq,maxFreq,maxNumBands:40);
	// SendReply.kr(Impulse.kr(30),"/melBands",[numBands] ++ melBands);
	source.dup;
}.play;
)

// observe the number of bands
x.set(\numBands,10);

// back to the full range
x.set(\numBands,40);

// focus all the bands on a mid range
x.set(\minFreq,320, \maxFreq, 800);

// focusing on the low end shows the fft resolution issue. One could restart the analysis with a larger fft to show more precision
x.set(\minFreq,20, \maxFreq, 160);

// back to full range
x.set(\minFreq,20, \maxFreq, 20000);

// free everything
x.free; b.free; c.free; r.stop;
::