TITLE:: FluidBufThresh
SUMMARY:: A Gate Processor for Buffers
CATEGORIES:: Libraries>FluidCorpusManipulation
RELATED:: Classes/FluidBufCompose,Classes/FluidGain,Classes/FluidStats,Guides/FluidCorpusManipulation,Guides/FluidBufMultiThreading
DESCRIPTION::

    
    Replace all values of a buffer under the given threshold with 0 and copy the result to a destination buffer.


    

Read more about FluidBufThresh on the link::https://learn.flucoma.org/reference/thresh##learn platform::.

CLASSMETHODS::

METHOD:: process, processBlocking
  Processs the source LINK::Classes/Buffer:: on the LINK::Classes/Server::. CODE::processBlocking:: will execute directly in the server command FIFO, whereas CODE::process:: will delegate to a separate worker thread. The latter is generally only worthwhile for longer-running jobs where you don't wish to tie up the server.

ARGUMENT:: server
	The LINK::Classes/Server:: on which the buffers to be processed are allocated.








ARGUMENT:: source

    
    The buffer to process containing the values to compare against the threshold.



ARGUMENT:: startFrame

    
    The starting point (in samples) from which to process the CODE::source::.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numFrames

    
    The duration (in samples) to process in the CODE::source::. The default (-1) indicates to process through the end of CODE::source::.



ARGUMENT:: startChan

    
    The channel from which to begin the process in the CODE::source::.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numChans

    
    The number of channels to process in CODE::source::. The default of -1 indicates to process through the last channel in CODE::source::.



ARGUMENT:: destination

    
    The buffer to write the processed data into.



ARGUMENT:: threshold

    
    Any values in CODE::source:: below this threshold will be written as 0 in CODE::destination::.



 
ARGUMENT:: freeWhenDone
  Free the server instance when processing complete. Default CODE::true::

ARGUMENT:: action
	A function to be evaluated once the offline process has finished and all Buffer's instance variables have been updated on the client side. The function will be passed CODE::[features]:: as an argument.

RETURNS:: An instance of the processor

METHOD:: kr
  Trigger the equivalent behaviour to CODE::processBlocking / process:: from a LINK::Classes/Synth::. Can be useful for expressing a sequence of buffer and data processing jobs to execute. Note that the work still executes on the server command FIFO (not the audio thread), and it is the caller's responsibility to manage the sequencing, using the CODE::done:: status of the various UGens.







ARGUMENT:: source

    
    The buffer to process containing the values to compare against the threshold.



ARGUMENT:: startFrame

    
    The starting point (in samples) from which to process the CODE::source::.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numFrames

    
    The duration (in samples) to process in the CODE::source::. The default (-1) indicates to process through the end of CODE::source::.



ARGUMENT:: startChan

    
    The channel from which to begin the process in the CODE::source::.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numChans

    
    The number of channels to process in CODE::source::. The default of -1 indicates to process through the last channel in CODE::source::.



ARGUMENT:: destination

    
    The buffer to write the processed data into.



ARGUMENT:: threshold

    
    Any values in CODE::source:: below this threshold will be written as 0 in CODE::destination::.



 
ARGUMENT:: trig
  A CODE::kr:: signal that will trigger execution

ARGUMENT:: blocking
  Whether to execute this process directly on the server command FIFO or delegate to a worker thread. See CODE::processBlocking/process:: for caveats.


INSTANCEMETHODS::

METHOD:: cancel
  Cancels non-blocking processing

METHOD:: wait
  When called in the context of a LINK::Classes/Routine:: (it won't work otherwise), will block execution until the processor has finished. This can be convinient for writing sequences of processes more linearly than using lots of nested actions.
  
EXAMPLES::
strong::Use with the FluidBufStats `weights` argument.:: Using the pitch confidence value of the FluidBufPitch analysis to weight the statistical analysis of the pitch value can improve the estimation of pitch (as the mean or median). By using FluidBufThresh, we can ensure that any pitch confidence values below a specified threshold will be "zeroed out" so their weight will be zero when calculating FluidBufStats.
code::

~scratchy = Buffer.read(s,FluidFilesPath("Tremblay-ASWINE-ScratchySynth-M.wav"));

~scratchy.play;

(
~pitch_analysis = Buffer(s);
FluidBufPitch.processBlocking(s,~scratchy,features:~pitch_analysis);
)

// look at the pitch analysis:
FluidWaveform(~scratchy,featuresBuffer:~pitch_analysis,stackFeatures:true,bounds:Rect(0,0,1600,400));

// get the median pitch
(
~pitch_stats = Buffer(s);
FluidBufStats.processBlocking(s,~pitch_analysis,numChans:1,stats:~pitch_stats);
~pitch_stats.loadToFloatArray(action:{
	arg fa;
	~median = fa[5];
	~median.postln;
});
)

// how does the pitch match? (not great)
(
~scratchy.play;
{SinOsc.ar(~median,0,0.01)}.play;
)

// use buf thresh to zero out all confidence values below a threshold:
(
~threshed_conf = Buffer(s);
FluidBufThresh.processBlocking(s,~pitch_analysis,startChan:1,destination:~threshed_conf,threshold:0.99);
)

// look at the thresholded values. (some will appear to not actually reach above the threshold...this is due to
// the interpolation happening for the drawing)
FluidWaveform(~scratchy,featuresBuffer:~threshed_conf,bounds:Rect(0,0,1600,400));

// now that anything below the threshold has become a zero, this will be useful for weighting the BufStats analysis
(
~pitch_stats = Buffer(s);
FluidBufStats.processBlocking(s,~pitch_analysis,numChans:1,stats:~pitch_stats,weights:~threshed_conf);
~pitch_stats.loadToFloatArray(action:{
	arg fa;
	~median = fa[5];
	~median.postln;
});
)

// does it match better? (it does)
(
~scratchy.play;
{SinOsc.ar(~median,0,0.01)}.play;
)

::
strong::A basic example to look at the output::
code::
// make a buffer with some values roughly 0 to 5
// and a buffer to write the output of FluidBufThresh into
(
~hundred = Buffer.loadCollection(s,(1..100).log);
~threshed = Buffer(s);
)

// take a look at the values
~hundred.plot;

// apply a threshold of 3
FluidBufThresh.processBlocking(s,~hundred,destination:~threshed,threshold:3);

// take a look at the output
~threshed.plot;

// composite them together (for looking at later)
(
~together = Buffer(s);
FluidBufCompose.processBlocking(s,~hundred,destination:~together);
FluidBufCompose.processBlocking(s,~threshed,destination:~together,destStartChan:1);
)

// plot it
FluidWaveform(featuresBuffer:~together,bounds:Rect(0,0,1600,400),lineWidth:2,normalizeFeaturesIndependently:false);

::
