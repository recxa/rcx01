TITLE:: FluidBufAmpSlice
SUMMARY:: Amplitude-based Detrending Slicer for Buffers
CATEGORIES:: Libraries>FluidCorpusManipulation
RELATED:: Classes/FluidAmpSlice,Classes/FluidBufAmpGate,Classes/FluidAmpGate,Classes/FluidBufOnsetSlice,Classes/FluidBufNoveltySlice,Classes/FluidBufTransientSlice,Guides/FluidCorpusManipulation,Classes/Amplitude
DESCRIPTION::

    
    Implements an amplitude-based slicer, with various customisable options and conditions to detect relative amplitude changes as onsets.


    
    FluidBufAmpSlice is based on two envelope followers on a high-passed version of the signal: one slow that gives the trend, and one fast. Each has features that will interact. The example code below is unfolding the various possibilities in order of complexity.

    The process will return a buffer which contains indices (in samples) of estimated starting points of different slices.


Read more about FluidBufAmpSlice on the link::https://learn.flucoma.org/reference/ampslice##learn platform::.

CLASSMETHODS::

METHOD:: process, processBlocking
  Processs the source LINK::Classes/Buffer:: on the LINK::Classes/Server::. CODE::processBlocking:: will execute directly in the server command FIFO, whereas CODE::process:: will delegate to a separate worker thread. The latter is generally only worthwhile for longer-running jobs where you don't wish to tie up the server.

ARGUMENT:: server
	The LINK::Classes/Server:: on which the buffers to be processed are allocated.








ARGUMENT:: source

    
    The buffer to use as the source material to be sliced through novelty identification. The different channels of multichannel buffers will be summed.



ARGUMENT:: startFrame

    
    Where in the srcBuf should the slicing process start, in samples.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numFrames

    
    How many frames should be processed.



ARGUMENT:: startChan

    
    For multichannel sources, which channel should be processed.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numChans

    
    For multichannel sources, how many channels should be summed.



ARGUMENT:: indices

    
    The buffer where the indices (in samples) of the estimated starting points of slices will be written. The first and last points are always the boundary points of the analysis.



ARGUMENT:: fastRampUp

    
    The number of samples the relative envelope follower will take to reach the next value when raising. Typically, this will be faster than slowRampUp.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: fastRampDown

    
    The number of samples the relative envelope follower will take to reach the next value when falling. Typically, this will be faster than slowRampDown.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: slowRampUp

    
    The number of samples the absolute envelope follower will take to reach the next value when raising.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: slowRampDown

    
    The number of samples the absolute envelope follower will take to reach the next value when falling.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: onThreshold

    
    The threshold in dB of the relative envelope follower to trigger an onset, aka to go ON when in OFF state. It is computed on the difference between the two envelope followers.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::-144::

    ## 
    Maximum: CODE::144::

    ::


ARGUMENT:: offThreshold

    
    The threshold in dB of the relative envelope follower to reset, aka to allow the differential envelope to trigger again.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::-144::

    ## 
    Maximum: CODE::144::

    ::


ARGUMENT:: floor

    
    The level in dB the slowRamp needs to be above to consider a detected difference valid, allowing to ignore the slices in the noise floor.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::-144::

    ## 
    Maximum: CODE::144::

    ::


ARGUMENT:: minSliceLength

    
    The length in samples that the Slice will stay ON. Changes of states during that period will be ignored.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: highPassFreq

    
    The frequency of the fourth-order Linkwitz–Riley high-pass filter (LINK::https://en.wikipedia.org/wiki/Linkwitz%E2%80%93Riley_filter::). This is done first on the signal to minimise low frequency intermodulation with very fast ramp lengths. A frequency of 0 bypasses the filter.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


 
ARGUMENT:: freeWhenDone
  Free the server instance when processing complete. Default CODE::true::

ARGUMENT:: action
	A function to be evaluated once the offline process has finished and all Buffer's instance variables have been updated on the client side. The function will be passed CODE::[features]:: as an argument.

RETURNS:: An instance of the processor

METHOD:: kr
  Trigger the equivalent behaviour to CODE::processBlocking / process:: from a LINK::Classes/Synth::. Can be useful for expressing a sequence of buffer and data processing jobs to execute. Note that the work still executes on the server command FIFO (not the audio thread), and it is the caller's responsibility to manage the sequencing, using the CODE::done:: status of the various UGens.







ARGUMENT:: source

    
    The buffer to use as the source material to be sliced through novelty identification. The different channels of multichannel buffers will be summed.



ARGUMENT:: startFrame

    
    Where in the srcBuf should the slicing process start, in samples.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numFrames

    
    How many frames should be processed.



ARGUMENT:: startChan

    
    For multichannel sources, which channel should be processed.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numChans

    
    For multichannel sources, how many channels should be summed.



ARGUMENT:: indices

    
    The buffer where the indices (in samples) of the estimated starting points of slices will be written. The first and last points are always the boundary points of the analysis.



ARGUMENT:: fastRampUp

    
    The number of samples the relative envelope follower will take to reach the next value when raising. Typically, this will be faster than slowRampUp.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: fastRampDown

    
    The number of samples the relative envelope follower will take to reach the next value when falling. Typically, this will be faster than slowRampDown.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: slowRampUp

    
    The number of samples the absolute envelope follower will take to reach the next value when raising.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: slowRampDown

    
    The number of samples the absolute envelope follower will take to reach the next value when falling.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: onThreshold

    
    The threshold in dB of the relative envelope follower to trigger an onset, aka to go ON when in OFF state. It is computed on the difference between the two envelope followers.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::-144::

    ## 
    Maximum: CODE::144::

    ::


ARGUMENT:: offThreshold

    
    The threshold in dB of the relative envelope follower to reset, aka to allow the differential envelope to trigger again.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::-144::

    ## 
    Maximum: CODE::144::

    ::


ARGUMENT:: floor

    
    The level in dB the slowRamp needs to be above to consider a detected difference valid, allowing to ignore the slices in the noise floor.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::-144::

    ## 
    Maximum: CODE::144::

    ::


ARGUMENT:: minSliceLength

    
    The length in samples that the Slice will stay ON. Changes of states during that period will be ignored.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: highPassFreq

    
    The frequency of the fourth-order Linkwitz–Riley high-pass filter (LINK::https://en.wikipedia.org/wiki/Linkwitz%E2%80%93Riley_filter::). This is done first on the signal to minimise low frequency intermodulation with very fast ramp lengths. A frequency of 0 bypasses the filter.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


 
ARGUMENT:: trig
  A CODE::kr:: signal that will trigger execution

ARGUMENT:: blocking
  Whether to execute this process directly on the server command FIFO or delegate to a worker thread. See CODE::processBlocking/process:: for caveats.


INSTANCEMETHODS::

METHOD:: cancel
  Cancels non-blocking processing

METHOD:: wait
  When called in the context of a LINK::Classes/Routine:: (it won't work otherwise), will block execution until the processor has finished. This can be convinient for writing sequences of processes more linearly than using lots of nested actions.
  
EXAMPLES::

code::
// detrending explained
// define a test signal and a destination buffer
(
b = Buffer.sendCollection(s, Array.fill(44100,{|i| sin(i*pi/ (44100/640)) * ((((79000-i) % 22050).abs / 28000.0) + 0.2)}));
c = Buffer.new(s);
)
// the source is a sinewave that does not go to silence and has sharp-ish amplitude bumps as onsets we try to track
b.play
b.plot

//process with symmetrical thresholds
FluidBufAmpSlice.process(s, b,indices: c,fastRampUp: 5,fastRampDown: 50,slowRampUp: 220,slowRampDown: 220, onThreshold: 10, offThreshold: 10,floor: -60);
c.query
c.getn(0,c.numFrames,{|item|item.postln;})

//beware of multiple triggers at the begining of the 2nd cycle above). A solution: Schmidth triggers
FluidBufAmpSlice.process(s, b,indices: c,fastRampUp: 5,fastRampDown: 50,slowRampUp: 220,slowRampDown: 220, onThreshold: 10, offThreshold: 7,floor: -60);
c.query
c.getn(0,c.numFrames,{|item|item.postln;})

// we got most of them sorted, but there is another solution: minslicelength
FluidBufAmpSlice.process(s, b,indices: c,fastRampUp: 5,fastRampDown: 50,slowRampUp: 220,slowRampDown: 220, onThreshold: 10, offThreshold: 7,floor: -60, minSliceLength: 500);
c.query
c.getn(0,c.numFrames,{|item|item.postln;})
::

STRONG::A musical example.::
CODE::
//load a buffer
(
b = Buffer.read(s,FluidFilesPath("Nicol-LoopE-M.wav"));
c = Buffer.new(s);
)

// slice the samples
FluidBufAmpSlice.process(s,b,indices:c,fastRampUp: 10,fastRampDown: 2205,slowRampUp: 4410,slowRampDown: 4410,onThreshold: 10,offThreshold: 5,floor: -40,minSliceLength: 4410,highPassFreq: 20);
c.query
c.getn(0,c.numFrames,{|item|item.postln;})

//loops over a splice with the MouseX
(
{
    BufRd.ar(1, b,
        Phasor.ar(0,1,
            BufRd.kr(1, c,
                MouseX.kr(0, BufFrames.kr(c) - 1), 0, 1),
            BufRd.kr(1, c,
                MouseX.kr(1, BufFrames.kr(c)), 0, 1),
            BufRd.kr(1,c,
                MouseX.kr(0, BufFrames.kr(c) - 1), 0, 1)), 0, 1);
        }.play;
)
::

STRONG::A stereo buffer example.::
CODE::
// make a stereo buffer
b = Buffer.alloc(s,88200,2);

// add some stereo clicks and listen to them
((0..3)*22050+11025).do({|item,index| b.set(item+(index%2), 1.0)})
b.play

// create a new buffer as destinations
c = Buffer.new(s);

//run the process on them
(
	// with basic params
	Routine{
		var t = Main.elapsedTime;
		var proc = FluidBufAmpSlice.process(s,b, indices: c, fastRampUp: 10,fastRampDown: 2205,slowRampUp: 4410,slowRampDown: 4410, onThreshold: 10,offThreshold: 5);
		proc.wait;
		c.query;
		(Main.elapsedTime - t).postln;
	}.play
)

// list the indicies of detected attacks - the two input channels have been summed.
c.getn(0,c.numFrames,{|item|(item * 2).postln;})
::
