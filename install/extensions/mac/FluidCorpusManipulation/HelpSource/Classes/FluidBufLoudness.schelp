TITLE:: FluidBufLoudness
SUMMARY:: A Loudness and True-Peak Descriptor on a Buffer
CATEGORIES:: Libraries>FluidCorpusManipulation
RELATED:: Classes/FluidLoudness,Classes/FluidBufPitch,Classes/FluidBufMelBands,Classes/FluidBufMFCC,Classes/FluidBufSpectralShape,Classes/FluidBufStats,Guides/FluidCorpusManipulation,Classes/Amplitude
DESCRIPTION::

    
    Two loudness descriptors, computing the true peak of the signal as well as applying the filters proposed by broadcasting standards to emulate the perception of amplitude.


    
    The process will return a multichannel buffer with two channels per input channel, one for loudness and one for the true peak value of the frame, both in dBfs.

    More information on broadcasting standardisation of loudness measurement is available at LINK::https://tech.ebu.ch/docs/tech/tech3341.pdf::, and in more musician-friendly explantions at LINK::http://designingsound.org/2013/02/06/loudness-and-metering-part-1/::.

    Each sample represents a value, which is every hopSize. Its sampling rate is sourceSR / hopSize.


Read more about FluidBufLoudness on the link::https://learn.flucoma.org/reference/loudness##learn platform::.

CLASSMETHODS::

METHOD:: process, processBlocking
  Processs the source LINK::Classes/Buffer:: on the LINK::Classes/Server::. CODE::processBlocking:: will execute directly in the server command FIFO, whereas CODE::process:: will delegate to a separate worker thread. The latter is generally only worthwhile for longer-running jobs where you don't wish to tie up the server.

ARGUMENT:: server
	The LINK::Classes/Server:: on which the buffers to be processed are allocated.








ARGUMENT:: source

    
    The buffer to use as the source material to be described. The different channels of multichannel buffers will be processed sequentially.



ARGUMENT:: startFrame

    
    Where in the srcBuf should the process start, in samples.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numFrames

    
    How many frames should be processed.



ARGUMENT:: startChan

    
    For multichannel srcBuf, which channel should be processed first.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numChans

    
    For multichannel srcBuf, how many channels should be processed.



ARGUMENT:: features

    
    The destination buffer for the loudness descriptors.



ARGUMENT:: select

    
    An array of CODE::symbols:: indicating which analyses to return. The options are CODE::loudness:: and CODE::peak::. If nothing is specified, the object will return all the analyses. The analyses will always appear in their normal order, this argument just allows for a selection of them to be returned. Reordering the options in this argument will not reorder how the analyses are returned.



ARGUMENT:: kWeighting

    
    A flag to switch the perceptual model of loudness. On by default, removing it makes the algorithm more CPU efficient by reverting to a simple RMS of the frame.



ARGUMENT:: truePeak

    
    A flag to switch the computation of TruePeak. On by default, removing it makes the algorithm more CPU efficient by reverting to a simple absolute peak of the frame.



ARGUMENT:: windowSize

    
    The size of the window on which the computation is done. By default, 1024 to be similar with all other FluCoMa objects, the EBU specifies 400ms, which is 17640 samples at 44100.

    STRONG::Constraints::

    LIST::
    ## 
    Maximum: CODE::maxWindowSize::

    ::


ARGUMENT:: hopSize

    
    How much the buffered window moves forward, in samples. By default, 512 to be similar with all other FluCoMa objects, the EBU specifies 100ms, which is 4410 samples at 44100.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: padding

    
    Controls the zero-padding added to either end of the source buffer or segment. Padding ensures all values are analysed. Possible values are:


table::## 0 || 
No padding - The first analysis window starts at time 0, and the samples at either end will be tapered by the STFT windowing function.
## 1 || 
Half the window size - The first sample is centred in the analysis window ensuring that the start and end of the segment are accounted for in the analysis.
## 2 || 
Window size minus the hop size - Mode 2 can be useful when the overlap factor (window size / hop size) is greater than 2, to ensure that the input samples at either end of the segment are covered by the same number of analysis frames as the rest of the analysed material.
::
 
ARGUMENT:: freeWhenDone
  Free the server instance when processing complete. Default CODE::true::

ARGUMENT:: action
	A function to be evaluated once the offline process has finished and all Buffer's instance variables have been updated on the client side. The function will be passed CODE::[features]:: as an argument.

RETURNS:: An instance of the processor

METHOD:: kr
  Trigger the equivalent behaviour to CODE::processBlocking / process:: from a LINK::Classes/Synth::. Can be useful for expressing a sequence of buffer and data processing jobs to execute. Note that the work still executes on the server command FIFO (not the audio thread), and it is the caller's responsibility to manage the sequencing, using the CODE::done:: status of the various UGens.







ARGUMENT:: source

    
    The buffer to use as the source material to be described. The different channels of multichannel buffers will be processed sequentially.



ARGUMENT:: startFrame

    
    Where in the srcBuf should the process start, in samples.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numFrames

    
    How many frames should be processed.



ARGUMENT:: startChan

    
    For multichannel srcBuf, which channel should be processed first.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numChans

    
    For multichannel srcBuf, how many channels should be processed.



ARGUMENT:: features

    
    The destination buffer for the loudness descriptors.



ARGUMENT:: select

    
    An array of CODE::symbols:: indicating which analyses to return. The options are CODE::loudness:: and CODE::peak::. If nothing is specified, the object will return all the analyses. The analyses will always appear in their normal order, this argument just allows for a selection of them to be returned. Reordering the options in this argument will not reorder how the analyses are returned.



ARGUMENT:: kWeighting

    
    A flag to switch the perceptual model of loudness. On by default, removing it makes the algorithm more CPU efficient by reverting to a simple RMS of the frame.



ARGUMENT:: truePeak

    
    A flag to switch the computation of TruePeak. On by default, removing it makes the algorithm more CPU efficient by reverting to a simple absolute peak of the frame.



ARGUMENT:: windowSize

    
    The size of the window on which the computation is done. By default, 1024 to be similar with all other FluCoMa objects, the EBU specifies 400ms, which is 17640 samples at 44100.

    STRONG::Constraints::

    LIST::
    ## 
    Maximum: CODE::maxWindowSize::

    ::


ARGUMENT:: hopSize

    
    How much the buffered window moves forward, in samples. By default, 512 to be similar with all other FluCoMa objects, the EBU specifies 100ms, which is 4410 samples at 44100.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: padding

    
    Controls the zero-padding added to either end of the source buffer or segment. Padding ensures all values are analysed. Possible values are:


table::## 0 || 
No padding - The first analysis window starts at time 0, and the samples at either end will be tapered by the STFT windowing function.
## 1 || 
Half the window size - The first sample is centred in the analysis window ensuring that the start and end of the segment are accounted for in the analysis.
## 2 || 
Window size minus the hop size - Mode 2 can be useful when the overlap factor (window size / hop size) is greater than 2, to ensure that the input samples at either end of the segment are covered by the same number of analysis frames as the rest of the analysed material.
::
 
ARGUMENT:: trig
  A CODE::kr:: signal that will trigger execution

ARGUMENT:: blocking
  Whether to execute this process directly on the server command FIFO or delegate to a worker thread. See CODE::processBlocking/process:: for caveats.


INSTANCEMETHODS::

METHOD:: cancel
  Cancels non-blocking processing

METHOD:: wait
  When called in the context of a LINK::Classes/Routine:: (it won't work otherwise), will block execution until the processor has finished. This can be convinient for writing sequences of processes more linearly than using lots of nested actions.
  
EXAMPLES::

code::

~src = Buffer.read(s,FluidFilesPath("Tremblay-AaS-AcousticStrums-M.wav"));

// blue is loudness dBFS, orange is true peak dBFS
(
~loudness = Buffer(s);
FluidBufLoudness.processBlocking(s,~src,features:~loudness);
FluidWaveform(~src,featuresBuffer:~loudness,bounds:Rect(0,0,1600,400),stackFeatures:true);
~src.play;
)

::
strong::Getting some useful loudness stats on an audio file (that is in a Buffer)::
As a result of the loudness wars, a statistical understanding of the loudness of an audio file (such as a rendered track) may be useful. Here are some ways you might use FluidBufLoudness this way.

The EBU standard specifies that the window should be 400ms long, and update every 100ms, for instantaneous loudness. Here we set the windowSize and hopSize appropriately using the sample rate of the source buffer.
code::

// stereo song
~src = Buffer.read(s,FluidFilesPath("Tremblay-beatRemember.wav"));

(
~loudness = Buffer(s);
FluidBufLoudness.processBlocking(s,~src,features:~loudness,windowSize:~src.sampleRate*0.4,hopSize:~src.sampleRate*0.1);
~stats = Buffer(s);
FluidBufStats.processBlocking(s,~loudness,stats:~stats);
~stats.loadToFloatArray(action:{
	arg fa;
	fa = fa.clump(~stats.numChannels).flop;
	"L channel mean   loudness:  % dB".format(fa[0][0]).postln;
	"L channel median loudness:  % dB".format(fa[0][5]).postln;
	"L channel max    true peak: % dB".format(fa[1][6]).postln;

	"R channel mean   loudness:  % dB".format(fa[2][0]).postln;
	"R channel median loudness:  % dB".format(fa[2][5]).postln;
	"R channel max    true peak: % dB".format(fa[3][6]).postln;
});
)

::