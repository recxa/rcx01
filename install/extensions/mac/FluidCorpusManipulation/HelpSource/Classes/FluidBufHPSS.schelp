TITLE:: FluidBufHPSS
SUMMARY:: Buffer-Based Harmonic-Percussive Source Separation Using Median Filtering
CATEGORIES:: Libraries>FluidCorpusManipulation
RELATED:: Classes/FluidHPSS,Classes/FluidBufSines,Classes/FluidBufTransients,Guides/FluidCorpusManipulation
DESCRIPTION::

    
    FluidBufHPSS performs Harmonic-Percussive Source Separation (HPSS) on the contents of a Buffer.


    
    DEFINITIONLIST::
    ## HPSS takes in audio and divides it into two or three outputs, depending on the CODE::maskingMode::
    || 
    LIST::
    ## 
    an harmonic component

    ## 
    a percussive component

    ## 
    a residual of the previous two if CODE::maskingMode:: is set to 2 (interdependent thresholds). See below.

    ::
    ::
    HPSS works by using median filters on the magnitudes of a spectrogram. It makes certain assumptions about what it is looking for in a sound: that in a spectrogram “percussive” elements tend to form vertical “ridges” (tall in frequency band, narrow in time), while stable “harmonic” elements tend to form horizontal “ridges” (narrow in frequency band, long in time). By using median filters across time and frequency respectively, we get initial estimates of the "harmonic-ness" and "percussive-ness" for every spectral bin of every spectral frame in the spectrogram. These are then combined into 'masks' that are applied to the original spectrogram in order to produce a harmonic and percussive output (and residual if CODE::maskingMode:: = 2).

    The maskingMode parameter provides different approaches to combining estimates and producing masks. Some settings (especially in modes 1 & 2) will provide better separation but with more artefacts.

    Driedger (2014) suggests that the size of the median filters don't affect the outcome as much as the CODE::fftSize::. With large FFT sizes, short percussive sounds have less representation, therefore the harmonic component is more strongly represented. The result is that many of the percussive sounds leak into the harmonic component. Small FFT sizes have less resolution in the frequency domain and often lead to a blurring of horizontal structures, therefore harmonic sounds tend to leak into the percussive component. As with all FFT based-processes, finding an FFT size that balances spectral and temporal resolution for a given source sound will benefit the use of this object.

    For more details visit LINK::https://learn.flucoma.org/reference/hpss::

    Fitzgerald, Derry. 2010. ‘Harmonic/Percussive Separation Using Median Filtering’. (In Proceedings DaFx 10. LINK::https://arrow.dit.ie/argcon/67::.)

    Driedger, Jonathan, Meinard Müller, and Sascha Disch. 2014. ‘Extending Harmonic-Percussive Separation of Audio Signals’. (In Proc. ISMIR. LINK::http://www.terasoft.com.tw/conf/ismir2014/proceedings/T110_127_Paper.pdf::.)


Read more about FluidBufHPSS on the link::https://learn.flucoma.org/reference/hpss##learn platform::.

CLASSMETHODS::

METHOD:: process, processBlocking
  Processs the source LINK::Classes/Buffer:: on the LINK::Classes/Server::. CODE::processBlocking:: will execute directly in the server command FIFO, whereas CODE::process:: will delegate to a separate worker thread. The latter is generally only worthwhile for longer-running jobs where you don't wish to tie up the server.

ARGUMENT:: server
	The LINK::Classes/Server:: on which the buffers to be processed are allocated.








ARGUMENT:: source

    
    The buffer to use as the source material. The channels of multichannel buffers will be processed sequentially.



ARGUMENT:: startFrame

    
    Where in the srcBuf should the HPSS process start, in samples.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numFrames

    
    How many frames should be processed.



ARGUMENT:: startChan

    
    For multichannel srcBuf, which channel to start processing at.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numChans

    
    For multichannel srcBuf, how many channels should be processed.



ARGUMENT:: harmonic

    
    The buffer where the extracted harmonic component will be reconstructed.



ARGUMENT:: percussive

    
    The buffer where the extracted percussive component will be reconstructed.



ARGUMENT:: residual

    
    The buffer where the residual component will be reconstructed in mode 2.



ARGUMENT:: harmFilterSize

    
    The size, in spectral frames, of the median filter for the harmonic component. Must be an odd number, >= 3.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::3::

    ## 
    Maximum: CODE::maxharmFilterSize::

    ## 
    Snaps to odd numbers

    ::


ARGUMENT:: percFilterSize

    
    The size, in spectral bins, of the median filter for the percussive component. Must be an odd number, >=3

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::3::

    ## 
    Maximum: CODE::maxpercFilterSize::

    ## 
    Snaps to odd numbers

    ::


ARGUMENT:: maskingMode

    
    The way the masking is applied to the original spectrogram.


table::## 0 || 
Soft masks provide the fewest artefacts, but the weakest separation. Complimentary, soft masks are made for the harmonic and percussive parts by allocating some fraction of every magnitude in the spectrogram to each mask. The two resulting buffers will sum to exactly the original material. This mode uses a soft mask in Fitzgerald's (2010) original method of 'Wiener-inspired' filtering.
## 1 || 
Binary masks provide better separation, but with more artefacts. The harmonic mask is constructed using a binary decision, based on whether a threshold is exceeded for every magnitude in the spectrogram (these are set using CODE::harmThreshFreq1::, CODE::harmThreshAmp1::, CODE::harmThreshFreq2::, CODE::harmThreshAmp2::, see below). The percussive mask is then formed as the inverse of the harmonic one, meaning that as above, the two components will sum to the original sound.
## 2 || 
Soft masks (with a third stream containing a residual component). First, binary masks are made separately for the harmonic and percussive components using different thresholds (set with the respective CODE::harmThresh-:: and CODE::percThresh-:: parameters below). Because these masks aren't guaranteed to represent the entire spectrogram, any residual energy is considered as a third output.  The independently created binary masks are converted to soft masks at the end of the process so that everything null-sums.
::
ARGUMENT:: harmThreshFreq1

    
    In modes 1 and 2, the frequency of the low part of the threshold for the harmonic filter (0-1)



ARGUMENT:: harmThreshAmp1

    
    In modes 1 and 2, the threshold of the low part for the harmonic filter. That threshold applies to all frequencies up to harmThreshFreq1: how much more powerful (in dB) the harmonic median filter needs to be than the percussive median filter for this bin to be counted as harmonic.



ARGUMENT:: harmThreshFreq2

    
    In modes 1 and 2, the frequency of the hight part of the threshold for the harmonic filter. (0-1)



ARGUMENT:: harmThreshAmp2

    
    In modes 1 and 2, the threshold of the high part for the harmonic filter. That threshold applies to all frequencies above harmThreshFreq2. The threshold between harmThreshFreq1 and harmThreshFreq2 is interpolated between harmThreshAmp1 and harmThreshAmp2. How much more powerful (in dB) the harmonic median filter needs to be than the percussive median filter for this bin to be counted as harmonic.



ARGUMENT:: percThreshFreq1

    
    In mode 2, the frequency of the low part of the threshold for the percussive filter. (0-1)



ARGUMENT:: percThreshAmp1

    
    In mode 2, the threshold of the low part for the percussive filter. That threshold applies to all frequencies up to percThreshFreq1. How much more powerful (in dB) the percussive median filter needs to be than the harmonic median filter for this bin to be counted as percussive.



ARGUMENT:: percThreshFreq2

    
    In mode 2, the frequency of the hight part of the threshold for the percussive filter. (0-1)



ARGUMENT:: percThreshAmp2

    
    In mode 2, the threshold of the high part for the percussive filter. That threshold applies to all frequencies above percThreshFreq2. The threshold between percThreshFreq1 and percThreshFreq2 is interpolated between percThreshAmp1 and percThreshAmp2. How much more powerful (in dB) the percussive median filter needs to be than the harmonic median filter for this bin to be counted as percussive.



ARGUMENT:: windowSize

    
    The window size in samples. As HPSS relies on spectral frames, we need to decide what precision we give it spectrally and temporally. For more information visit LINK::https://learn.flucoma.org/learn/fourier-transform/::



ARGUMENT:: hopSize

    
    The hop size in samples. As HPSS relies on spectral frames, we need to move the window forward. It can be any size, but low overlap may create audible artefacts.



ARGUMENT:: fftSize

    
    The inner FFT/IFFT size. It should be at least 4 samples long; at least the size of the window; and a power of 2. Making it larger than the window size provides interpolation in frequency.



 
ARGUMENT:: freeWhenDone
  Free the server instance when processing complete. Default CODE::true::

ARGUMENT:: action
	A function to be evaluated once the offline process has finished and all Buffer's instance variables have been updated on the client side. The function will be passed CODE::[features]:: as an argument.

RETURNS:: An instance of the processor

METHOD:: kr
  Trigger the equivalent behaviour to CODE::processBlocking / process:: from a LINK::Classes/Synth::. Can be useful for expressing a sequence of buffer and data processing jobs to execute. Note that the work still executes on the server command FIFO (not the audio thread), and it is the caller's responsibility to manage the sequencing, using the CODE::done:: status of the various UGens.







ARGUMENT:: source

    
    The buffer to use as the source material. The channels of multichannel buffers will be processed sequentially.



ARGUMENT:: startFrame

    
    Where in the srcBuf should the HPSS process start, in samples.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numFrames

    
    How many frames should be processed.



ARGUMENT:: startChan

    
    For multichannel srcBuf, which channel to start processing at.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: numChans

    
    For multichannel srcBuf, how many channels should be processed.



ARGUMENT:: harmonic

    
    The buffer where the extracted harmonic component will be reconstructed.



ARGUMENT:: percussive

    
    The buffer where the extracted percussive component will be reconstructed.



ARGUMENT:: residual

    
    The buffer where the residual component will be reconstructed in mode 2.



ARGUMENT:: harmFilterSize

    
    The size, in spectral frames, of the median filter for the harmonic component. Must be an odd number, >= 3.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::3::

    ## 
    Maximum: CODE::maxharmFilterSize::

    ## 
    Snaps to odd numbers

    ::


ARGUMENT:: percFilterSize

    
    The size, in spectral bins, of the median filter for the percussive component. Must be an odd number, >=3

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::3::

    ## 
    Maximum: CODE::maxpercFilterSize::

    ## 
    Snaps to odd numbers

    ::


ARGUMENT:: maskingMode

    
    The way the masking is applied to the original spectrogram.


table::## 0 || 
Soft masks provide the fewest artefacts, but the weakest separation. Complimentary, soft masks are made for the harmonic and percussive parts by allocating some fraction of every magnitude in the spectrogram to each mask. The two resulting buffers will sum to exactly the original material. This mode uses a soft mask in Fitzgerald's (2010) original method of 'Wiener-inspired' filtering.
## 1 || 
Binary masks provide better separation, but with more artefacts. The harmonic mask is constructed using a binary decision, based on whether a threshold is exceeded for every magnitude in the spectrogram (these are set using CODE::harmThreshFreq1::, CODE::harmThreshAmp1::, CODE::harmThreshFreq2::, CODE::harmThreshAmp2::, see below). The percussive mask is then formed as the inverse of the harmonic one, meaning that as above, the two components will sum to the original sound.
## 2 || 
Soft masks (with a third stream containing a residual component). First, binary masks are made separately for the harmonic and percussive components using different thresholds (set with the respective CODE::harmThresh-:: and CODE::percThresh-:: parameters below). Because these masks aren't guaranteed to represent the entire spectrogram, any residual energy is considered as a third output.  The independently created binary masks are converted to soft masks at the end of the process so that everything null-sums.
::
ARGUMENT:: harmThreshFreq1

    
    In modes 1 and 2, the frequency of the low part of the threshold for the harmonic filter (0-1)



ARGUMENT:: harmThreshAmp1

    
    In modes 1 and 2, the threshold of the low part for the harmonic filter. That threshold applies to all frequencies up to harmThreshFreq1: how much more powerful (in dB) the harmonic median filter needs to be than the percussive median filter for this bin to be counted as harmonic.



ARGUMENT:: harmThreshFreq2

    
    In modes 1 and 2, the frequency of the hight part of the threshold for the harmonic filter. (0-1)



ARGUMENT:: harmThreshAmp2

    
    In modes 1 and 2, the threshold of the high part for the harmonic filter. That threshold applies to all frequencies above harmThreshFreq2. The threshold between harmThreshFreq1 and harmThreshFreq2 is interpolated between harmThreshAmp1 and harmThreshAmp2. How much more powerful (in dB) the harmonic median filter needs to be than the percussive median filter for this bin to be counted as harmonic.



ARGUMENT:: percThreshFreq1

    
    In mode 2, the frequency of the low part of the threshold for the percussive filter. (0-1)



ARGUMENT:: percThreshAmp1

    
    In mode 2, the threshold of the low part for the percussive filter. That threshold applies to all frequencies up to percThreshFreq1. How much more powerful (in dB) the percussive median filter needs to be than the harmonic median filter for this bin to be counted as percussive.



ARGUMENT:: percThreshFreq2

    
    In mode 2, the frequency of the hight part of the threshold for the percussive filter. (0-1)



ARGUMENT:: percThreshAmp2

    
    In mode 2, the threshold of the high part for the percussive filter. That threshold applies to all frequencies above percThreshFreq2. The threshold between percThreshFreq1 and percThreshFreq2 is interpolated between percThreshAmp1 and percThreshAmp2. How much more powerful (in dB) the percussive median filter needs to be than the harmonic median filter for this bin to be counted as percussive.



ARGUMENT:: windowSize

    
    The window size in samples. As HPSS relies on spectral frames, we need to decide what precision we give it spectrally and temporally. For more information visit LINK::https://learn.flucoma.org/learn/fourier-transform/::



ARGUMENT:: hopSize

    
    The hop size in samples. As HPSS relies on spectral frames, we need to move the window forward. It can be any size, but low overlap may create audible artefacts.



ARGUMENT:: fftSize

    
    The inner FFT/IFFT size. It should be at least 4 samples long; at least the size of the window; and a power of 2. Making it larger than the window size provides interpolation in frequency.



 
ARGUMENT:: trig
  A CODE::kr:: signal that will trigger execution

ARGUMENT:: blocking
  Whether to execute this process directly on the server command FIFO or delegate to a worker thread. See CODE::processBlocking/process:: for caveats.


INSTANCEMETHODS::

METHOD:: cancel
  Cancels non-blocking processing

METHOD:: wait
  When called in the context of a LINK::Classes/Routine:: (it won't work otherwise), will block execution until the processor has finished. This can be convinient for writing sequences of processes more linearly than using lots of nested actions.
  
EXAMPLES::

STRONG::Mode 0::

CODE::

//load buffers
(
~src = Buffer.read(s,FluidFilesPath("Nicol-LoopE-M.wav"));
~harmonic = Buffer.new(s);
~percussive = Buffer.new(s);
)

// run with basic parameters
FluidBufHPSS.processBlocking(s,~src,harmonic:~harmonic,percussive:~percussive,action:{"done".postln;});

//play the harmonic
~harmonic.play;

//play the percussive
~percussive.play;

(
// See which parts of the Waveform are in which component
// blue = harmonic, orange = percussive
~fw = FluidWaveform(bounds:Rect(0,0,1600,400));
~fw.addAudioLayer(~harmonic,FluidViewer.categoryColors[0].alpha_(0.5));
~fw.addAudioLayer(~percussive,FluidViewer.categoryColors[1].alpha_(0.5));
~fw.front;
)

::

STRONG::Separating Components before Analysis (using Mode 1)::

CODE::

~src = Buffer.read(s,FluidFilesPath("Tremblay-AaS-SynthTwoVoices-M.wav"));

// hear it
~src.play;

// let's look at some pitch analysis first
(
~pitch_analysis = Buffer(s);
FluidBufPitch.processBlocking(s,~src,features:~pitch_analysis,minFreq:40,maxFreq:500,windowSize:4096);
FluidWaveform(~src,featuresBuffer:~pitch_analysis,bounds:Rect(0,400,1600,400),stackFeatures:true);
)
// it's getting the "pitch" of all the clicks (the peaky spikes in the blue pitch plot),
// but perhaps I just want the pitch analysis of the bass line

// now let's do the pitch analysis using just the harmonic component
// because we're interested in strong separation and don't need to care about artefacts, maskingMode = 1
(
~harmonic = Buffer(s);
FluidBufHPSS.processBlocking(s,~src,harmonic:~harmonic,harmFilterSize:17,percFilterSize:31,maskingMode:1);
FluidBufPitch.processBlocking(s,~harmonic,features:~pitch_analysis,minFreq:40,maxFreq:500,windowSize:4096);
FluidWaveform(~harmonic,featuresBuffer:~pitch_analysis,bounds:Rect(0,0,1600,400),stackFeatures:true);
)
// except for a few spikes at the end, this is much more usable for extracting the pitch of the bass notes.

// take a listen to what it's analyzing
~harmonic.play;

::

STRONG::Mode 2::

CODE::

(
~src = Buffer.read(s,FluidFilesPath("Tremblay-CF-ChurchBells.wav"));
~residual = Buffer.new(s);
~harmonic = Buffer.new(s);
~percussive = Buffer.new(s);
)

// listen to the original;
~src.play

(
// this will take a few seconds (wait for "done" to post):
FluidBufHPSS.processBlocking(s,~src,harmonic:~harmonic,percussive:~percussive,residual:~residual,harmFilterSize:71,percFilterSize:31,maskingMode:2,harmThreshFreq1:0.005,harmThreshAmp1:3,harmThreshFreq2:0.2,harmThreshAmp2:6,percThreshFreq1:0.004,percThreshAmp1:3,percThreshFreq2:0.152,percThreshAmp2:3,windowSize:4096,hopSize:512,action:{"done".postln;})
)

// listen to the different parts
~harmonic.play; // some artefacts, but mostly the "harmonic" partials of the bells
~percussive.play; // has most of the "noisy" content of the bell resonance
~residual.play; // a bit of both, more of the attack

::
