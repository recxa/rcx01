TITLE:: FluidAmpGate
SUMMARY:: Gate Detection on a Signal
CATEGORIES:: Libraries>FluidCorpusManipulation
RELATED:: Classes/FluidBufAmpGate,Classes/FluidAmpSlice,Classes/FluidBufAmpSlice,Classes/FluidOnsetSlice,Classes/FluidNoveltySlice,Classes/FluidTransientSlice,Guides/FluidCorpusManipulation
DESCRIPTION::

    
    Absolute amplitude threshold gate detector on a realtime signal


    
    AmpGate outputs an audio-rate, single-channel signal that is either 0, indicating the gate is closed, or 1, indicating the gate is open. The gate detects an onset (opens) when the internal envelope follower (controlled by CODE::rampUp:: and CODE::rampDown::) goes above a specified CODE::onThreshold:: (in dB) for at least CODE::minLengthAbove:: samples. The gate will stay open until the envelope follower goes below CODE::offThreshold:: (in dB) for at least CODE::minLengthBelow:: samples, which triggers an offset.

    The latency between the input and the output is STRONG::max(minLengthAbove + lookBack, max(minLengthBelow,lookAhead))::.


Read more about FluidAmpGate on the link::https://learn.flucoma.org/reference/ampgate##learn platform::.

CLASSMETHODS::

METHOD:: ar

ARGUMENT:: in 

  Audio-rate signal to slice








ARGUMENT:: rampUp

    
    The number of samples the envelope follower will take to reach the next value when rising.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: rampDown

    
    The number of samples the envelope follower will take to reach the next value when falling.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: onThreshold

    
    The threshold in dB of the envelope follower to trigger an onset: go from 0 (closed) to 1 (open).

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::-144::

    ## 
    Maximum: CODE::144::

    ::


ARGUMENT:: offThreshold

    
    The threshold in dB of the envelope follower to trigger an offset: go from 1 (open) to 0 (closed).

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::-144::

    ## 
    Maximum: CODE::144::

    ::


ARGUMENT:: minSliceLength

    
    The minimum length in samples for which the gate will stay open. Changes of states during this period after an onset will be ignored.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: minSilenceLength

    
    The minimum length in samples for which the gate will stay closed. Changes of states during that period after an offset will be ignored.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: minLengthAbove

    
    The length in samples that the envelope must be above the threshold to consider it a valid transition to 1. The gate will change to 1 at the first sample when the condition is met. Therefore, this affects the latency (see latency equation in the description).

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: minLengthBelow

    
    The length in samples that the envelope must be below the threshold to consider it a valid transition to 0. The gate will change to 0 at the first sample when the condition is met. Therefore, this affects the latency (see latency equation in the description).

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    ::


ARGUMENT:: lookBack

    
    When an onset is detected, the algorithm will look in the recent past (via an internal recorded buffer of this length in samples) for a minimum in the envelope follower to identify as the onset point. This affects the latency of the algorithm (see latency equation in the description).

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: lookAhead

    
    When an offset is detected, the algorithm will wait this duration (in samples) to find a minimum in the envelope follower to identify as the offset point. This affects the latency of the algorithm (see latency equation in the description).

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


ARGUMENT:: highPassFreq

    
    The frequency of the fourth-order Linkwitz-Riley high-pass filter (LINK::https://en.wikipedia.org/wiki/Linkwitz%E2%80%93Riley_filter::) applied to the input signal to minimise low frequency intermodulation with very short ramp lengths. A frequency of 0 bypasses the filter.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0::

    ::


 
ARGUMENT:: maxSize

    
    The size of the buffer to allocate at instantiation time for keeping track of the time-critical conditions (CODE::minSliceLength::, CODE::minSilenceLength::, CODE::minLengthAbove::, CODE::minLengthBelow::, CODE::lookBack::, and CODE::lookAhead::). This cannot be modulated.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::1::

    :: 

INSTANCEMETHODS::
  
EXAMPLES::
strong::Watch the gate::
code::

// make sure the third bus is only output.
(
s.options.numOutputBusChannels_(4);
s.options.numInputBusChannels_(4);
s.reboot;
)

~src = Buffer.read(s,FluidFilesPath("Nicol-LoopE-M.wav"));

(
{
	var source = PlayBuf.ar(1,~src,BufRateScale.ir(~src),loop:1);
	var env = FluidAmpGate.ar(source, rampUp:441, rampDown:2205, onThreshold:-27, offThreshold: -31, minSilenceLength:4410, lookBack:441, highPassFreq:20).poll;
	var sig = DelayN.ar(source,delaytime:441/44100) * env.lag(0.02); // compenstate for latency.
	[sig,sig,env];
}.scope;
)

::
strong::Use for manipulating FX::
code::

~src = Buffer.read(s,FluidFilesPath("Harker-DS-TenOboeMultiphonics-M.wav"));

(
{
	arg thresh = -35;
	var src = PlayBuf.ar(1,~src,BufRateScale.ir(~src),loop:1);
	var localbuf = LocalBuf(s.sampleRate).clear;
	var gate = FluidAmpGate.ar(src,10,10,thresh,thresh-5,441,441,441,441).poll;
	var phs = Phasor.ar(0,1 * gate,0,localbuf.numFrames/2); // only write into the buffer when the gate is open
	var trig = Dust.kr(50) * (1-gate); // only trigger grains from that buffer when the gate is closed
	var dur = 0.1;
	var pos = ((phs + localbuf.numFrames/2) - TRand.kr(dur*SampleRate.ir,localbuf.numFrames/2)) / localbuf.numFrames;
	var sig = GrainBuf.ar(2,trig,dur,localbuf,1,pos,4,TChoose.kr(trig,[-0.9,0.9]),mul:6.dbamp);
	BufWr.ar(src,localbuf,[phs,phs+(localbuf.numFrames/2)]);
	sig + src;
}.scope;
)

::