TITLE:: FluidBufThreadDemo
SUMMARY:: A Tutorial Object to Experiment with Multithreading in FluidBuf* Objects
CATEGORIES:: Libraries>FluidCorpusManipulation
RELATED:: Guides/FluidCorpusManipulation,Guides/FluidBufMultiThreading
DESCRIPTION::

    
    Implements a tutorial object to illustrate and experiment with the behaviour of the FluidBuf* objects. To simulate their behaviour in various blocking modes, the object after waiting for STRONG::time:: milliseconds, return its delay length as a float writen at index [0] of the specified destination buffer.


    

Read more about FluidBufThreadDemo on the link::https://learn.flucoma.org/reference/bufthreaddemo##learn platform::.

CLASSMETHODS::

METHOD:: process, processBlocking
  Processs the source LINK::Classes/Buffer:: on the LINK::Classes/Server::. CODE::processBlocking:: will execute directly in the server command FIFO, whereas CODE::process:: will delegate to a separate worker thread. The latter is generally only worthwhile for longer-running jobs where you don't wish to tie up the server.

ARGUMENT:: server
	The LINK::Classes/Server:: on which the buffers to be processed are allocated.








ARGUMENT:: result

    
    The destination buffer, where the value should be written at the end of the process.



ARGUMENT:: time

    
    The duration in milliseconds of the delay that the background thread will wait for before yielding the value to the destination buffer.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0.0::

    ::


 
ARGUMENT:: freeWhenDone
  Free the server instance when processing complete. Default CODE::true::

ARGUMENT:: action
	A function to be evaluated once the offline process has finished and all Buffer's instance variables have been updated on the client side. The function will be passed CODE::[features]:: as an argument.

RETURNS:: An instance of the processor

METHOD:: kr
  Trigger the equivalent behaviour to CODE::processBlocking / process:: from a LINK::Classes/Synth::. Can be useful for expressing a sequence of buffer and data processing jobs to execute. Note that the work still executes on the server command FIFO (not the audio thread), and it is the caller's responsibility to manage the sequencing, using the CODE::done:: status of the various UGens.







ARGUMENT:: result

    
    The destination buffer, where the value should be written at the end of the process.



ARGUMENT:: time

    
    The duration in milliseconds of the delay that the background thread will wait for before yielding the value to the destination buffer.

    STRONG::Constraints::

    LIST::
    ## 
    Minimum: CODE::0.0::

    ::


 
ARGUMENT:: trig
  A CODE::kr:: signal that will trigger execution

ARGUMENT:: blocking
  Whether to execute this process directly on the server command FIFO or delegate to a worker thread. See CODE::processBlocking/process:: for caveats.


INSTANCEMETHODS::

METHOD:: cancel
  Cancels non-blocking processing

METHOD:: wait
  When called in the context of a LINK::Classes/Routine:: (it won't work otherwise), will block execution until the processor has finished. This can be convinient for writing sequences of processes more linearly than using lots of nested actions.
  
EXAMPLES::

For a thorough explanation, please refer to the tutorial on link::Guides/FluidBufMultiThreading::.
Using code::.process:: will spawn a new thread to do the processing.

CODE::
// define a destination buffer
b = Buffer.alloc(s,1);

// a simple call, where we query the destination buffer upon completion with the action message.
FluidBufThreadDemo.process(s, b, 1000, action:{|x|x.get(0,{|y|y.postln});});

// as the 'process' returns its instance, we can cancel the process easily
c = FluidBufThreadDemo.process(s, b, 100000, action: {|x|x.get(0,{|y|y.postln});});
c.cancel;

// if a simple call to the UGen is used, the progress can be monitored. The usual cmd-period will cancel the job by freeing the synth.
(
{
	c = FluidBufThreadDemo.kr(b,10000).poll;
	FreeSelfWhenDone.kr(c)
}.scope;
)
::
strong::processBlocking::

Using code::.processBlocking:: will add the process to the OCS server queue to ensure that the operations get done in order.
code::

b = Buffer.alloc(s,1);

(
FluidBufThreadDemo.processBlocking(s, b, 1000, action:{"job 1 done".postln});
FluidBufThreadDemo.processBlocking(s, b, 500, action:{"job 2 done".postln});
FluidBufThreadDemo.processBlocking(s, b, 1500, action:{"job 3 done".postln});
)

(
fork{
	FluidBufThreadDemo.processBlocking(s, b, 1000, action:{"job 1 done".postln});
	s.sync;
	FluidBufThreadDemo.processBlocking(s, b, 500, action:{"job 2 done".postln});
	s.sync;
	FluidBufThreadDemo.processBlocking(s, b, 1500, action:{"job 3 done".postln});
}
)
::